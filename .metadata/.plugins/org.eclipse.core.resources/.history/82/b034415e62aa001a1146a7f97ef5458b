#include <freertos/FreeRTOS.h>
#include <freertos/semphr.h>
#include <freertos/task.h>

#include "GlobalStandards.h"

#include <hal/Timing/Time.h>
#include "SubSystemModules/Communication/SatCommandHandler.h"


#include <satellite-subsystems/IsisTRXVU.h>
#include <satellite-subsystems/IsisAntS.h>
#ifdef ISISEPS
	#include <satellite-subsystems/isis_eps_driver.h>
#endif
#ifdef GOMEPS
	#include <satellite-subsystems/GomEPS.h>
#endif


#include <hcc/api_fat.h>
#include <hal/Drivers/I2C.h>
#include <stdlib.h>
#include <string.h>
#include <hal/errors.h>
#include "TLM_management.h"
#include "SubSystemModules/Communication/TRXVU.h"
#include "SubSystemModules/Communication/AckHandler.h"
#include "SubSystemModules/Maintenance/Maintenance.h"
#include "Maintanence_Commands.h"

#define RESET_KEY 0xA6 // need to send this key to the reset command otherwise reset will not happen

// data in SPL should be: slaveaddr,size of data to get back from the I2C command ,data to sent to I2C
// TODO: how to test this function??
int CMD_GenericI2C(sat_packet_t *cmd)
{
	if(cmd == NULL || cmd->data == NULL){
		return E_INPUT_POINTER_NULL;
	}
	int err = 0;
	unsigned char slaveAddr = 0;
	unsigned int size = 0;
	unsigned char *i2c_data = malloc(size);

	memcpy(&slaveAddr,cmd->data,sizeof(slaveAddr));
	memcpy(&size,cmd->data + sizeof(slaveAddr),sizeof(size));

	unsigned int offset = sizeof(slaveAddr) + sizeof(size);
	//err = I2C_write((unsigned int)slaveAddr,cmd->data + offset, cmd->length);
	err = I2C_write((unsigned int)slaveAddr,cmd->data + offset, (cmd->length - offset));
	err = I2C_read((unsigned int)slaveAddr,i2c_data,size);
	if (err == E_NO_SS_ERR){
		TransmitDataAsSPL_Packet(cmd, i2c_data, size);
	}
	free(i2c_data);

	return err;
}

// SPL data should be: addr(int),size of data to read
int CMD_FRAM_ReadAndTransmitt(sat_packet_t *cmd)
{
	if (cmd == NULL || cmd->data == NULL){
		return E_INPUT_POINTER_NULL;
	}
	int err = 0;
	unsigned int addr = 0;
	unsigned int size = 0;

	memcpy(&addr, cmd->data, sizeof(addr));
	memcpy(&size, cmd->data + sizeof(addr),sizeof(size));

	unsigned char *read_data = malloc(size);
	if(NULL == read_data){
		return E_MEM_ALLOC;
	}

	int i=0;
	err = FRAM_read((unsigned char*)&i, addr, size); // TODO: ask why using read_data doesn't work
	if (err == E_NO_SS_ERR){
		TransmitDataAsSPL_Packet(cmd, &i, size);
	}

	free(read_data);
	return err;
}

// SPL data should be: addr(int),data
int CMD_FRAM_WriteAndTransmitt(sat_packet_t *cmd)
{
	if (cmd == NULL || cmd->data == NULL){
		return E_INPUT_POINTER_NULL;
	}
	int err = 0;
	unsigned int addr = 0;
	unsigned int length = cmd->length;
	unsigned char *data = cmd->data;

	memcpy(&addr, cmd->data, sizeof(addr));

	err = FRAM_write(data + sizeof(addr), addr, length - sizeof(addr));
	if (err != E_NO_SS_ERR){
		return err;
	}
	err = FRAM_read(data, addr, length - sizeof(addr));
	if (err == E_NO_SS_ERR){
		TransmitDataAsSPL_Packet(cmd, data, length);
	}
	return err;
}

int CMD_FRAM_Start(sat_packet_t *cmd)
{
	int err = 0;
	err = FRAM_start();
	if (err == E_NO_SS_ERR)
	{
		TransmitDataAsSPL_Packet(cmd, (unsigned char*)&err, sizeof(err));
	}
	return err;
}

int CMD_FRAM_Stop(sat_packet_t *cmd)
{

	FRAM_stop();
		SendAckPacket(ACK_COMD_EXEC, cmd, NULL, 0);
	return 0;
}

int CMD_FRAM_GetDeviceID(sat_packet_t *cmd)
{

	unsigned char id;
	int err = FRAM_getDeviceID(&id);
	if (err == E_NO_SS_ERR)
	{
		TransmitDataAsSPL_Packet(cmd, &id, sizeof(id));
	}
	return err;
}

int CMD_UpdateSatTime(sat_packet_t *cmd)
{
	if (cmd == NULL || cmd->data == NULL){
		return E_INPUT_POINTER_NULL;
	}
	int err = 0;
	time_unix set_time = 0;
	memcpy(&set_time, cmd->data, sizeof(set_time));
	err = Time_setUnixEpoch(set_time);
	if (err == E_NO_SS_ERR)
	{
		TransmitDataAsSPL_Packet(cmd, (unsigned char*)&set_time, sizeof(set_time));
	}
	return err;
}

int CMD_GetSatTime(sat_packet_t *cmd)
{
	int err = 0;
	time_unix curr_time = 0;
	err = Time_getUnixEpoch(&curr_time);
	if (err == E_NO_SS_ERR)
	{
		TransmitDataAsSPL_Packet(cmd, (unsigned char*)&curr_time, sizeof(curr_time));
	}

	return err;
}

int CMD_GetSatUptime(sat_packet_t *cmd)
{

	time_unix uptime = 0;
	uptime = Time_getUptimeSeconds();
	TransmitDataAsSPL_Packet(cmd, (unsigned char*)&uptime, sizeof(uptime));
	return 0;
}

int CMD_SoftTRXVU_ComponenetReset(sat_packet_t *cmd)
{
	if (cmd == NULL || cmd->data == NULL)
	{
		return E_INPUT_POINTER_NULL;
	}

	int err = 0;
	ISIStrxvuComponent component;
	memcpy(&component, cmd->data, sizeof(component));

	err = IsisTrxvu_componentSoftReset(ISIS_TRXVU_I2C_BUS_INDEX, component);
	return err;
}

int CMD_HardTRXVU_ComponenetReset(sat_packet_t *cmd)
{
	if (cmd == NULL || cmd->data == NULL)
	{
		return E_INPUT_POINTER_NULL;
	}

	int err = 0;
	ISIStrxvuComponent component;
	memcpy(&component, cmd->data, sizeof(component));

	err = IsisTrxvu_componentHardReset(ISIS_TRXVU_I2C_BUS_INDEX, component);
	return err;
}


int CMD_ResetComponent(sat_packet_t *cmd)
{
	int err = 0;

	Boolean8bit reset_flag = TRUE_8BIT;

	char restType=0;
	memcpy(&restType, cmd->data, sizeof(char));

	switch (restType)
	{
	case reset_software:
		SendAckPacket(ACK_SOFT_RESET, cmd, NULL, 0);
		FRAM_write(&reset_flag, RESET_CMD_FLAG_ADDR, RESET_CMD_FLAG_SIZE);
		vTaskDelay(10);
		restart();
		break;
/*
		//don't need this as we have the eps reset
	case reset_hardware:
		SendAckPacket(ACK_HARD_RESET, cmd, NULL, 0);
		FRAM_write(&reset_flag, RESET_CMD_FLAG_ADDR, RESET_CMD_FLAG_SIZE);
		vTaskDelay(10);
		break;
*/
	case reset_eps: // this is a soft reset of the MCU
		SendAckPacket(ACK_EPS_RESET, cmd, NULL, 0);
		FRAM_write(&reset_flag, RESET_CMD_FLAG_ADDR, RESET_CMD_FLAG_SIZE);
		vTaskDelay(10);
		isis_eps__reset__to_t cmd_t;
		isis_eps__reset__from_t cmd_f;
		cmd_t.fields.rst_key = RESET_KEY;
		logError(isis_eps__reset__tmtc(EPS_I2C_BUS_INDEX, &cmd_t, &cmd_f),"CMD_ResetComponent-isis_eps__reset__tmtc");
		break;

	case reset_trxvu_hard:
		SendAckPacket(ACK_TRXVU_HARD_RESET, cmd, NULL, 0);
		logError(IsisTrxvu_hardReset(ISIS_TRXVU_I2C_BUS_INDEX));
		vTaskDelay(100);
		break;

	case reset_trxvu_soft:
		SendAckPacket(ACK_TRXVU_SOFT_RESET, cmd, NULL, 0);
		logError(IsisTrxvu_softReset(ISIS_TRXVU_I2C_BUS_INDEX));
		vTaskDelay(100);
		break;

	case reset_filesystem:
		DeInitializeFS(); //TODO not working well
		vTaskDelay(10);
		err = (unsigned int) InitializeFS(FALSE);
		vTaskDelay(10);
		if (err == E_NO_SS_ERR) SendAckPacket(ACK_FS_RESET, cmd, (unsigned char*) &err, sizeof(err));
		break;

	case reset_ant_SideA:
		err = logError(IsisAntS_reset(ISIS_TRXVU_I2C_BUS_INDEX, isisants_sideA));
		if (err == E_NO_SS_ERR) SendAckPacket(ACK_ANTS_RESET, cmd, (unsigned char*) &err, sizeof(err));
		break;

	case reset_ant_SideB:
		err=logError(IsisAntS_reset(ISIS_TRXVU_I2C_BUS_INDEX, isisants_sideB));
		if (err == E_NO_SS_ERR) SendAckPacket(ACK_ANTS_RESET, cmd, (unsigned char*) &err, sizeof(err));
		break;

	default:
		SendAckPacket(ACK_UNKNOWN_SUBTYPE, cmd, NULL, 0);
		break;
	}
	vTaskDelay(10);
	return err;
}
